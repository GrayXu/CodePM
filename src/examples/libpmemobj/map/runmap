#!/bin/bash
#
# Copyright 2018, University of California, San Diego
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#
#     * Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# The argument parsing part of this bash script is generated by
# https://argbash.io/generate using the following configurations.

# ARG_OPTIONAL_SINGLE([nops],        [n], [number of operations], [10])
# ARG_OPTIONAL_SINGLE([mode],        [m], [transaction mode in data_store], [0])
# ARG_OPTIONAL_SINGLE([exit],        [x], [exit point from data_store.c], [0])
#
# ARG_OPTIONAL_BOOLEAN([gdb],        [d], [run the program with gdb], [off])
# ARG_OPTIONAL_BOOLEAN([report],     [r], [report data analysis on the pool file], [off])
#
# ARG_POSITIONAL_SINGLE([type],           [data store structure (ctree,rbtree,hashmap_tx,btree,rtree)])
#
# ARG_HELP([Run a data structure for KV store])
#
# ARGBASH_SET_INDENT([    ])
# ARGBASH_GO

# Example runs:
# ./runmap ctree -n 100 -m 1 -x 0
# ./runmap all -n 100000 -m 0 -x 0
# ./runmap btree -n 100 -m 1 -x 0 --gdb
# for i in 0 1 2 3 4; do ./runmap all -n 100000 -m 0 -x $i; done
# for i in 0 1 2 3 4; do ./runmap all -n 100000 -m 1 -x $i; done

die()
{
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option()
{
    local first_option all_short_options
    all_short_options='nmxdrh'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_nops="10"
_arg_mode="0"
_arg_exit="0"
_arg_gdb="off"
_arg_report="off"

print_help ()
{
    printf '%s\n' "Run a data structure for KV store"
    printf 'Usage: %s [-n|--nops <arg>] [-m|--mode <arg>] [-x|--exit <arg>] [-d|--(no-)gdb] [-r|--(no-)report] [-h|--help] <type>\n' "$0"
    printf '\t%s\n' "<type>: data store structure (ctree,rbtree,hashmap_tx,btree,rtree)"
    printf '\t%s\n' "-n,--nops: number of operations (default: '10')"
    printf '\t%s\n' "-m,--mode: transaction mode in data_store (default: '0')"
    printf '\t%s\n' "-x,--exit: exit point from data_store.c (default: '0')"
    printf '\t%s\n' "-d,--gdb,--no-gdb: run the program with gdb (off by default)"
    printf '\t%s\n' "-r,--report,--no-report: report data analysis on the pool file (off by default)"
    printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
    while test $# -gt 0
    do
        _key="$1"
        case "$_key" in
            -n|--nops)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_nops="$2"
                shift
                ;;
            --nops=*)
                _arg_nops="${_key##--nops=}"
                ;;
            -n*)
                _arg_nops="${_key##-n}"
                ;;
            -m|--mode)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_mode="$2"
                shift
                ;;
            --mode=*)
                _arg_mode="${_key##--mode=}"
                ;;
            -m*)
                _arg_mode="${_key##-m}"
                ;;
            -x|--exit)
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _arg_exit="$2"
                shift
                ;;
            --exit=*)
                _arg_exit="${_key##--exit=}"
                ;;
            -x*)
                _arg_exit="${_key##-x}"
                ;;
            -d|--no-gdb|--gdb)
                _arg_gdb="on"
                test "${1:0:5}" = "--no-" && _arg_gdb="off"
                ;;
            -d*)
                _arg_gdb="on"
                _next="${_key##-d}"
                if test -n "$_next" -a "$_next" != "$_key"
                then
                    begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                fi
                ;;
            -r|--no-report|--report)
                _arg_report="on"
                test "${1:0:5}" = "--no-" && _arg_report="off"
                ;;
            -r*)
                _arg_report="on"
                _next="${_key##-r}"
                if test -n "$_next" -a "$_next" != "$_key"
                then
                    begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                fi
                ;;
            -h|--help)
                print_help
                exit 0
                ;;
            -h*)
                print_help
                exit 0
                ;;
            *)
                _positionals+=("$1")
                ;;
        esac
        shift
    done
}

handle_passed_args_count ()
{
    _required_args_string="'type'"
    test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
    test ${#_positionals[@]} -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
    _positional_names=('_arg_type' )

    for (( ii = 0; ii < ${#_positionals[@]}; ii++))
    do
        eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
    done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

#                                                                              #
# -------------------------- end of argument parsing ------------------------- #
#                                                                              #

print_run_env ()
{
    echo
    echo "PMEM_IS_PMEM_FORCE = $PMEM_IS_PMEM_FORCE"
    echo "TX_MODE            = $TX_MODE"
    echo "EXIT_POINT         = $EXIT_POINT"
    echo
}

export PMEM_IS_PMEM_FORCE=1

export TX_MODE=$_arg_mode
export EXIT_POINT=$_arg_exit

print_run_env

#
# Run program
#

run_one ()
{
    dstype=$1
    nops=$2

    poolfile=/mnt/pmem/$dstype
    rm -f $poolfile

    echo "Running $_arg_nops $dstype operations on $poolfile ..."

    if   [ "$_arg_gdb" == "on" ]; then
        gdb --args ./data_store $dstype $poolfile $nops
    else
        ./data_store $dstype $poolfile $nops
    fi

    echo && echo "Finishd $nops operations"

    if [ "$_arg_report" == "on" ]; then
        echo "Analyzing $poolfile ..."

        hexdump -C $poolfile > $dstype.dump
        echo "$poolfile content dumped to $dstype.dump"

        nkey=$(cat $dstype.dump | grep KEY | wc -l)
        nval=$(cat $dstype.dump | grep VAL | wc -l)
        csum=$(cat $dstype.dump | grep CSUM | wc -l)

        printf "%8s %10s %10s\n" "KEY" "VAL" "CSUM"
        printf "%8s %10s %10s\n" $nkey $nval $csum

    fi
}

case "$_arg_type" in
    all)
        for map in ctree rbtree btree skiplist rtree hashmap_tx; do
            run_one $map $_arg_nops
            echo "----------------------------------------------------------------------------------------------------"
        done
        exit 0
        ;;
    ctree|rbtree|btree|skiplist|rtree|hashmap_tx)
        run_one $_arg_type $_arg_nops
        exit 0
        ;;
    *)
        printf "Type $_arg_type is not supported!\n\n"
        print_help
        ;;
esac
